### 外观模式介绍  
外观模式（Facade），为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用。引入外观角色之后，用户只需要直接与外观角色交互，用户与子系统之间的复杂关系由外观角色来实现，从而降低了系统的耦合度。  

举个例子来更清晰的理解：在我们的App中通常都会集成进入多种分享SDK，每一种分享SDK都有各自的文档与要求，但是对于我们客户端而言，其实分享的内容都是一样的，可是又要去看那么多不同的文档就显得很麻烦。这时，就有了ShareSDK这类的第三方SDK来帮助我们快速的完成分享，我们不用再关心内部的不同分享途径的不同实现了。其实ShareSDK就是外观模式的运用，它提供了一个高层次的接口，使得各个子系统（不同的分享SDK）更易于使用。   

![Markdown](http://i2.tiimg.com/1949/77c63ef365b847d6.png)


### 外观模式使用场景  
1. 为一个复杂子系统提供一个简单接口。子系统往往会因为不断演化而变得越来越复杂，此时通过外观模式提供一个简单统一的接口，对外隐藏子系统的具体实现、隔离变化  
2. 当你需要构建一个层次结构的子系统时，使用外观模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，可以让它们仅通过外观模式提供的接口进行通信，从而简化了它们之间的依赖关系。  


### 外观模式的简单实例   
其实，生活中使用外观模式的例子就非常多。手机就是一个外观模式的例子，它集合了电话功能，拍照功能，GPS等等，我们可以把这这些功能当作一个个的子系统，手机就是通过外观模式提供出来的高层次接口。  
```java
public class MobilePhone {
    private Phone mPhone = new Phone();
    private Camera mCamera = new Camera();
    public void call() ｛
        mPhone.call();
    ｝
    public void takePhoto() {
        mCamera.open();
        mCamera.takPhoto();
        mCamera.close();
    }
}
```
这是就直接写一个简单的示例，一个MobilePhone类，里面包含了两个子系统，分别是拨号系统和拍照系统，MobilePhone将这两个子系统封装起来，为用户提供了一个统计的操作接口。用户只用调用里面有两个方法，就可以完成打电话和拍照，用户不用再关系里面的子系统是怎么样的。  
当然因为这只是一个示例，所以写的子系统比较少。真实的项目中，一般子系统都会更加的复杂的。  

### Android中的外观模式  
在Android开发过程中Context是一个非常关键的类，意为上下文。 
[熟悉这个类](https://github.com/whyalwaysmea/LearningNotes/blob/master/Android/Context.md)的都知道它是一个抽象类，具体的实现类是ContextImpl，它封装了很多重要的操作，如`startActivity()`,`sendBroadcast()`,`bindService()`等，但是这些操作并不是真正的由Context来完成的。比如`startActivity()`，真正的实现是通过ActivityManagerService；获取应用包相关 则是通过`PackageManagerService`完成。因此Context对于开发者来说是一个重要的高层接口。  

### 总结  
外观模式的精髓在于封装。通过高层次结构为用户提供统一的API入口，使得用户通过一个类型就基本能够操作整个系统，这样减少了用户的使用成本，也能够提升系统的灵活性。 
**优点：**  
1. 对客户程序隐藏子系统细节，因而减少了客户对于子系统的耦合，能够拥抱变化 
2. 外观类对子系统的接口封装，使得系统更易于使用  

**缺点：**  
1. 外观类接口膨胀。由于子系统的接口都由外观类统一对外暴露，使得外观类的接口较多。
2. 外观类没有遵循开闭原则，当业务出现变更时，可能需要修改外观类。  


