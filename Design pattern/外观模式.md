### 外观模式介绍  
外观模式（Facade），为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用。引入外观角色之后，用户只需要直接与外观角色交互，用户与子系统之间的复杂关系由外观角色来实现，从而降低了系统的耦合度。  

举个例子来更清晰的理解：在我们的App中通常都会集成进入多种分享SDK，每一种分享SDK都有各自的文档与要求，但是对于我们客户端而言，其实分享的内容都是一样的，可是又要去看那么多不同的文档就显得很麻烦。这时，就有了ShareSDK这类的第三方SDK来帮助我们快速的完成分享，我们不用再关心内部的不同分享途径的不同实现了。其实ShareSDK就是外观模式的运用，它提供了一个高层次的接口，使得各个子系统（不同的分享SDK）更易于使用。   

![Markdown](http://i2.tiimg.com/1949/77c63ef365b847d6.png)


### 外观模式使用场景  
1. 为一个复杂子系统提供一个简单接口。子系统往往会因为不断演化而变得越来越复杂，此时通过外观模式提供一个简单统一的接口，对外隐藏子系统的具体实现、隔离变化  
2. 当你需要构建一个层次结构的子系统时，使用外观模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，可以让它们仅通过外观模式提供的接口进行通信，从而简化了它们之间的依赖关系。  


### 外观模式的简单实例   
其实，生活中使用外观模式的例子就非常多。手机就是一个外观模式的例子，它集合了电话功能，拍照功能，GPS等等，我们可以把这这些功能当作一个个的子系统，手机就是通过外观模式提供出来的高层次接口。  
```java
public class MobilePhone {
    private Phone mPhone = new Phone();
    private Camera mCamera = new Camera();
    public void call() ｛
        mPhone.call();
    ｝
    public void takePhoto() {
        mCamera.open();
        mCamera.takPhoto();
        mCamera.close();
    }
}
```
这是就直接写一个简单的示例，一个MobilePhone类，里面包含了两个子系统，分别是拨号系统和拍照系统，MobilePhone将这两个子系统封装起来，为用户提供了一个统计的操作接口。用户只用调用里面有两个方法，就可以完成打电话和拍照，用户不用再关系里面的子系统是怎么样的。  
当然因为这只是一个示例，所以写的子系统比较少。真实的项目中，一般子系统都会更加的复杂的。  


